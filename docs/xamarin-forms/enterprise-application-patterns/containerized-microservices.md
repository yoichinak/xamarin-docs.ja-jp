---
title: "コンテナー化されたマイクロサービス" 説明: "この章では、マイクロサービスとコンテナーを使用して、アジャイルでスケーラブルで信頼性の高い最新のクラウドアプリケーションを構築する方法について説明します。"
ms. 製品: xamarin ms assetid: 5872ad92-04e047 f1a-9691-79 d5602f5683 ms. テクノロジ: xamarin-forms author: davidbritch: dabritch ms. date: 08/07/2017 no loc: [ Xamarin.Forms , Xamarin.Essentials ]
---

# <a name="containerized-microservices"></a>コンテナー化 Microservices

クライアントサーバーアプリケーションを開発することにより、各層で特定のテクノロジを使用する階層型アプリケーションを構築することに重点を置いてきました。 このようなアプリケーションは、多くの場合*モノリシック*アプリケーションと呼ばれ、ピーク時の負荷のために事前にスケーリングされたハードウェアにパッケージ化されます。 この開発アプローチの主な欠点は、各層内のコンポーネント間の密結合であり、個々のコンポーネントを簡単にスケーリングできないこと、およびテストコストがかかることです。 単純な更新では、階層の残りの部分に予期しない影響が生じる可能性があるため、アプリケーションコンポーネントに変更を適用するには、階層全体を再構成して再デプロイする必要があります。

特にクラウドの時代に関しては、個々のコンポーネントを簡単にスケーリングすることはできません。 モノリシックアプリケーションにはドメイン固有の機能が含まれており、通常はフロントエンド、ビジネスロジック、データストレージなどの機能層によって分割されます。 図8-1 に示すように、アプリケーション全体を複数のコンピューターに複製することで、モノリシックアプリケーションが拡張されます。

![](containerized-microservices-images/monolithicapp.png "Monolithic application scaling approach")

**図 8-1**: モノリシックアプリケーションのスケーリングアプローチ

## <a name="microservices"></a>マイクロサービス

マイクロサービスは、アプリケーションの開発とデプロイに対してさまざまなアプローチを提供します。これは、最新のクラウドアプリケーションの機敏性、拡張性、信頼性の要件に適したアプローチです。 マイクロサービスアプリケーションは、アプリケーションの全体的な機能を提供するために連携する独立したコンポーネントに分解されます。 マイクロサービスという用語は、個々のマイクロサービスが1つの関数を実装できるように、独立した問題を反映するのに十分な数のサービスからアプリケーションを構成する必要があることを意味します。 さらに、各マイクロサービスには明確に定義されたコントラクトがあるため、他のマイクロサービスがデータと通信してデータを共有できるようになります。 マイクロサービスの典型的な例としては、ショッピングカート、在庫処理、購入サブシステム、支払い処理などがあります。

マイクロサービスは、一緒にスケールアウトされるジャイアントモノリシックアプリケーションと比較して、個別にスケールアウトできます。 これは、要求をサポートするためにより多くの処理能力またはネットワーク帯域幅を必要とする特定の機能領域で、アプリケーションの他の領域を不必要にスケールアウトするのではなく、スケーリングできることを意味します。 図8-2 は、マイクロサービスが個別にデプロイおよびスケーリングされ、マシン間でサービスのインスタンスを作成する方法を示しています。

![](containerized-microservices-images/microservicesapp.png "Microservices application scaling approach")

**図 8-2**: マイクロサービスアプリケーションのスケーリングアプローチ

マイクロサービスのスケールアウトはほぼ瞬時に行うことができるため、アプリケーションは負荷の変化に適応できます。 たとえば、アプリケーションの web に接続する機能の1つのマイクロサービスは、追加の受信トラフィックを処理するためにスケールアウトする必要があるアプリケーションの唯一のマイクロサービスである場合があります。

アプリケーションのスケーラビリティに関する従来のモデルでは、永続的なデータを格納するための共有外部データストアを使用して、負荷分散されたステートレスレベルを使用します。 ステートフルマイクロサービスは、独自の永続データを管理します。通常は、それらが配置されているサーバー上にローカルに格納します。これにより、サービス間の操作のオーバーヘッドを回避できます。 これにより、データを迅速に処理できるため、システムをキャッシュする必要がなくなります。 さらに、スケーラブルなステートフルマイクロサービスは通常、インスタンス間でデータをパーティション分割し、1台のサーバーでサポートできるデータサイズと転送スループットを管理します。

マイクロサービスでは、独立した更新もサポートしています。 マイクロサービス間の疎結合により、高速で信頼性の高いアプリケーションの進化が実現します。 独立した分散型の性質は、特定の時点で1つのマイクロサービスのインスタンスのサブセットのみが更新されるローリング更新をサポートしています。 したがって、問題が検出された場合、すべてのインスタンスが問題のあるコードまたは構成で更新される前に、バグのある更新プログラムをロールバックできます。 同様に、マイクロサービスは通常、スキーマのバージョン管理を使用します。これにより、通信しているマイクロサービスインスタンスに関係なく、更新プログラムが適用されるときにクライアントに一貫したバージョンが表示されます。

そのため、マイクロサービスアプリケーションには、モノリシックアプリケーションよりも多くのメリットがあります。

- 各マイクロサービスは比較的小規模で、管理と進化が簡単です。
- 各マイクロサービスは、他のサービスとは別に開発およびデプロイできます。
- 各マイクロサービスは個別にスケールアウトできます。 たとえば、カタログサービスやショッピングバスケットサービスは、注文サービスよりもスケールアウトが必要になる場合があります。 そのため、スケールアウトすると、結果として得られるインフラストラクチャによってリソースが効率的に消費されます。
- 各マイクロサービスは、すべての問題を分離します。 たとえば、サービスに問題がある場合は、そのサービスにのみ影響します。 他のサービスは、要求を処理し続けることができます。
- 各マイクロサービスは、最新のテクノロジを使用できます。 マイクロサービスは独立して並列実行されるため、モノリシックアプリケーションで使用される可能性がある古いフレームワークを強制的に使用するのではなく、最新のテクノロジとフレームワークを使用できます。

ただし、マイクロサービスベースのソリューションにも潜在的な欠点があります。

- アプリケーションをマイクロサービスにパーティション分割する方法を選択するのは困難な場合があります。各マイクロサービスは、データソースの責任を含めて、エンドツーエンドで完全に自律的にする必要があるためです。
- 開発者はサービス間通信を実装する必要があります。これにより、アプリケーションの複雑さと待機時間が増加します。
- 通常、複数のマイクロサービス間でアトミックトランザクションを実行することはできません。 そのため、ビジネス要件はマイクロサービス間の最終的な整合性を受け入れる必要があります。
- 運用環境では、多数の独立したサービスが侵害されたシステムの展開と管理には、運用上の複雑さがあります。
- クライアントからマイクロサービスへの直接通信によって、マイクロサービスのコントラクトをリファクターするのが困難になる場合があります。 たとえば、システムをサービスに分割する時間の経過と共に、変更が必要になる場合があります。 1つのサービスが2つ以上のサービスに分割され、2つのサービスがマージされる可能性があります。 クライアントがマイクロサービスと直接通信する場合、このリファクタリング作業によってクライアントアプリとの互換性が損なわれる可能性があります。

## <a name="containerization"></a>コンテナー化

コンテナー化は、アプリケーションとそのバージョンの依存関係、および配置マニフェストファイルとして抽象化された環境構成を、コンテナーイメージとしてパッケージ化し、1つのユニットとしてテストし、ホストオペレーティングシステムに展開するソフトウェア開発の手法です。

コンテナーは、分離、リソース制御、およびポータブルオペレーティング環境で、アプリケーションは他のコンテナーのリソースやホストに関係なく実行できます。 そのため、コンテナーは、新しくインストールされた物理コンピューターや仮想マシンのように見え、動作します。

図8-3 に示すように、コンテナーと仮想マシンの間には多くの類似点があります。

![](containerized-microservices-images/containersvsvirtualmachines.png "Microservices application scaling approach")

**図 8-3**: 仮想マシンとコンテナーの比較

コンテナーは、オペレーティングシステムを実行し、ファイルシステムを備えており、物理マシンまたは仮想マシンのようにネットワーク経由でアクセスできます。 ただし、コンテナーで使用されるテクノロジと概念は、仮想マシンとは大きく異なります。 仮想マシンには、アプリケーション、必要な依存関係、および完全なゲストオペレーティングシステムが含まれます。 コンテナーには、アプリケーションとその依存関係が含まれますが、ホストオペレーティングシステム上で分離プロセスとして実行されている他のコンテナーとオペレーティングシステムを共有します (コンテナーごとに特殊な仮想マシンの内部で実行される Hyper-v コンテナーを除く)。 そのため、コンテナーはリソースを共有し、通常は仮想マシンよりも必要なリソースを減らすことができます。

コンテナー指向の開発と展開のアプローチの利点は、不整合な環境設定やそれらに付随する問題に起因する問題のほとんどを排除することです。 さらに、コンテナーは、必要に応じて新しいコンテナーをインスタンス化することで、アプリケーションの高速スケールアップ機能を許可します。

コンテナーを作成して操作する際の主な概念は次のとおりです。

- コンテナーホスト: コンテナーをホストするように構成された物理または仮想マシン。 コンテナーホストは、1つまたは複数のコンテナーを実行します。
- コンテナーイメージ: イメージは、相互に積み重ねられた階層型ファイルシステムの和集合で構成され、コンテナーの基礎となります。 イメージには状態がないため、異なる環境に配置されるときに変更されることはありません。
- コンテナー: コンテナーは、イメージのランタイムインスタンスです。
- コンテナーの OS イメージ: コンテナーは、イメージから展開されます。 コンテナーオペレーティングシステムイメージは、コンテナーを構成する多くのイメージレイヤーの最初のレイヤーです。 コンテナーのオペレーティングシステムは不変であり、変更することはできません。
- コンテナーリポジトリ: コンテナーイメージが作成されるたびに、イメージとその依存関係がローカルリポジトリに格納されます。 これらのイメージは、コンテナー ホストで何度も再利用できます。 コンテナーイメージは、別のコンテナーホスト間で使用できるように、 [Docker Hub](https://hub.docker.com/)などのパブリックまたはプライベートレジストリに格納することもできます。

マイクロサービスベースのアプリケーションを実装するときに、企業はコンテナーを導入することがますます高まっており、Docker は、ほとんどのソフトウェアプラットフォームとクラウドベンダーが採用している標準のコンテナー実装になっています。

EShopOnContainers 参照アプリケーションは、図8-4 に示すように、Docker を使用して、4つのコンテナー化されたバックエンドマイクロサービスをホストします。

![](containerized-microservices-images/microservicesarchitecture.png "eShopOnContainers reference application back-end microservices")

**図 8-4**: eShopOnContainers reference application バックエンドマイクロサービス

参照アプリケーションのバックエンドサービスのアーキテクチャは、コラボレーションマイクロサービスとコンテナーの形式で複数の自律サブシステムに分解されます。 各マイクロサービスは、id サービス、カタログサービス、注文サービス、およびバスケットサービスという1つの機能を提供します。

各マイクロサービスには独自のデータベースがあるため、他のマイクロサービスから完全に分離することができます。 必要に応じて、さまざまなマイクロサービスのデータベース間の一貫性をアプリケーションレベルのイベントを使用して実現できます。 詳細については、「[マイクロサービス間の通信](#communication-between-microservices)」を参照してください。

参照アプリケーションの詳細については、「 [.Net マイクロサービス: コンテナー化された .Net アプリケーションのアーキテクチャ](https://aka.ms/microservicesebook)」を参照してください。

## <a name="communication-between-client-and-microservices"></a>クライアントとマイクロサービス間の通信

EShopOnContainers モバイルアプリは、図8-5 に示すように、*クライアントからマイクロサービスへの直接*通信を使用して、コンテナー化されたバックエンドマイクロサービスと通信します。

![](containerized-microservices-images/directclienttomicroservicecommunication.png "Microservices application scaling approach")

**図 8-5**: クライアントからマイクロサービスへの直接通信

クライアントからマイクロサービスへの直接通信では、モバイルアプリはパブリックエンドポイントを介して各マイクロサービスに要求を直接送信し、マイクロサービスごとに異なる TCP ポートを使用します。 運用環境では、エンドポイントは通常、使用可能なインスタンスに要求を分散するマイクロサービスのロードバランサーにマップされます。

> [!TIP]
> API ゲートウェイ通信の使用を検討してください。 クライアントからマイクロサービスへの直接通信には、大規模で複雑なマイクロサービスベースのアプリケーションを構築するときに欠点がありますが、小規模なアプリケーションには適していません。 数十のマイクロサービスを含む大規模なマイクロサービスベースのアプリケーションを設計する場合は、API ゲートウェイ通信の使用を検討してください。 詳細については、「 [.Net マイクロサービス: コンテナー化された .Net アプリケーションのアーキテクチャ](https://aka.ms/microservicesebook)」を参照してください。

## <a name="communication-between-microservices"></a>マイクロサービス間の通信

マイクロサービスベースのアプリケーションは、複数のコンピューターで実行される可能性がある分散システムです。 通常、各サービス インスタンスはプロセスです。 そのため、サービスは、各サービスの性質に応じて、HTTP、TCP、Advanced Message Queuing Protocol (AMQP)、バイナリプロトコルなどのプロセス間通信プロトコルを使用して対話する必要があります。

マイクロサービスとマイクロサービス間の通信には、2つの一般的なアプローチとして、データを照会するときに HTTP ベースの REST 通信が使用されます。また、複数のマイクロサービス間で更新を伝達する場合は、軽量の非同期メッセージングがあります。

非同期メッセージングベースのイベントドリブン通信は、複数のマイクロサービスにわたって変更を反映するときに重要です。 このアプローチでは、ビジネスエンティティを更新するときなど、注目すべき出来事が発生したときにマイクロサービスがイベントを発行します。 その他のマイクロサービスは、これらのイベントをサブスクライブします。 これにより、マイクロサービスがイベントを受け取ると、独自のビジネスエンティティが更新され、さらに多くのイベントが発行される可能性があります。 このパブリッシュ/サブスクライブ機能は、通常、イベントバスを使用して実現されます。

イベントバスを使用すると、図8-6 に示すように、コンポーネントが互いを明示的に認識する必要がなく、マイクロサービス間で公開/サブスクライブ通信を行うことができます。

![](containerized-microservices-images/eventbus.png "Publish-subscribe with an event bus")

**図 8-6:** イベントバスを使用したパブリッシュとサブスクライブ

アプリケーションの観点から見ると、イベントバスは、単にインターフェイスを介して公開されるサブスクライブチャネルです。 ただし、イベントバスの実装方法は異なる場合があります。 たとえば、イベントバスの実装では、RabbitMQ、Azure Service Bus、または NServiceBus や MassTransit などのその他のサービスバスを使用できます。 図8-7 は、eShopOnContainers 参照アプリケーションでのイベントバスの使用方法を示しています。

![](containerized-microservices-images/microservicesarchitecturewitheventbus.png "Asynchronous event-driven communication in the reference application")

**図 8-7:** 参照アプリケーションでの非同期イベントドリブン通信

RabbitMQ を使用して実装される eShopOnContainers イベントバスは、1対多の非同期パブリッシュ/サブスクライブ機能を提供します。 これは、イベントを発行した後、複数のサブスクライバーが同じイベントをリッスンしている可能性があることを意味します。 図8-9 は、この関係を示しています。

![](containerized-microservices-images/eventdrivencommunication.png "One-to-many communication")

**図 8-9**: 1 対多の通信

この一対多の通信方法では、イベントを使用して、複数のサービスにまたがるビジネストランザクションを実装し、サービス間の最終的な整合性を確保します。 最終的に一貫性のあるトランザクションは、一連の分散ステップで構成されます。 そのため、ユーザープロファイルマイクロサービスが UpdateUser コマンドを受け取ると、そのデータベース内のユーザーの詳細が更新され、UserUpdated イベントがイベントバスに発行されます。 バスケットマイクロサービスと注文マイクロサービスは、このイベントを受信するためにサブスクライブしています。また、応答として、それぞれのデータベースで購入者情報を更新します。

> [!NOTE]
> RabbitMQ を使用して実装される eShopOnContainers イベントバスは、概念実証としてのみ使用することを目的としています。 実稼働システムでは、代替のイベントバス実装を検討する必要があります。

イベントバスの実装の詳細については、「 [.Net マイクロサービス: コンテナー化された .Net アプリケーションのアーキテクチャ](https://aka.ms/microservicesebook)」を参照してください。

## <a name="summary"></a>まとめ

マイクロサービスは、最新のクラウドアプリケーションの機敏性、拡張性、信頼性の要件に適した、アプリケーションの開発とデプロイに対するアプローチを提供します。 マイクロサービスの主な利点の1つは、個別にスケールアウトできることです。これは、需要の増加に対応していないアプリケーションの領域を不必要に拡大することなく、需要をサポートするためにより多くの処理能力やネットワーク帯域幅を必要とする特定の機能領域をスケーリングできることを意味します。

コンテナーは、分離、リソース制御、およびポータブルオペレーティング環境で、アプリケーションは他のコンテナーのリソースやホストに関係なく実行できます。 マイクロサービスベースのアプリケーションを実装するときに、企業はコンテナーを導入することがますます高まっており、Docker は、ほとんどのソフトウェアプラットフォームとクラウドベンダーが採用している標準のコンテナー実装になっています。

## <a name="related-links"></a>関連リンク

- [電子ブックのダウンロード (2 Mb PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (サンプル)](https://github.com/dotnet-architecture/eShopOnContainers)
